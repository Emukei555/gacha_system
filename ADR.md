# ADR-001: エラー処理におけるResultパターンの採用

## ステータス
Accepted

## 日付
2026-01-19

## コンテキスト
現在、ドメイン層におけるバリデーションやビジネスルールの違反（例：残高不足、条件不一致）の通知方法が定まっていない。
従来の「検査例外（Checked Exception）」や「実行時例外（RuntimeException）」を利用する方法には、以下の課題がある。

1. **制御フローの隠蔽**: 例外はGOTO文のような性質を持ち、コードのどこで処理が中断されるかが可視化されにくい。
2. **型安全性の欠如**: コンパイラは実行時例外のハンドリングを強制しないため、エラー処理の漏れが本番環境での障害につながるリスクがある。
3. **ドメイン表現の欠落**: ビジネス上の「失敗（Failure）」もまた、システムにとっては重要な「事実（Fact）」であり、例外として扱うべきではない。

私は、コンパイラの支援を受けて堅牢なシステムを構築する必要がある。

## 検討した選択肢

### 選択肢1: Result<T> パターンの採用（Railway Oriented Programming）
戻り値として「成功（値）」と「失敗（エラー）」のいずれかを持つラッパーオブジェクトを返す手法。

* **メリット:**
    * **コンパイラによる強制**: 呼び出し元は必ず `isSuccess()` や `map/flatMap` を通じて結果を確認する必要があり、ハンドリング漏れが物理的に不可能になる。
    * **制御フローの明示**: メソッドシグネチャ `Result<Wallet>` を見るだけで、失敗する可能性があることが一目で分かる。
* **デメリット:**
    * **記述量の増加**: 毎回結果をアンラップ（開封）するコードが必要になる。
    * **標準ライブラリとの乖離**: Java標準APIやJPAは例外を投げるため、境界での変換（Adapter）が必要。

### 選択肢2: 実行時例外（RuntimeException）の利用
Spring Bootの標準的なエラーハンドリング手法。

* **メリット:**
    * **記述の簡潔さ**: 正常系のロジックだけを記述でき、エラーは自動的に上位層へ伝播する。
    * **フレームワークとの親和性**: `@Transactional` がデフォルトでロールバックしてくれる。
* **デメリット:**
    * **暗黙的な依存**: どのメソッドがどの例外を投げるかがJavadoc頼みになり、実装者が変わり次第、容易に崩壊する。

## 決定
**選択肢1: Result<T> パターンを採用する**

## 決定の理由
本プロジェクトにおける最優先事項は「ドメインルールの整合性維持」であるため。
記述量が増えるトレードオフを受け入れてでも、不正状態（負値・上限超過など）を型システムレベルで検知し、呼び出し側に処理を強制させる設計を選択した。

例外は「DB接続断」などの**システム異常（復旧不可能）**のみに限定し、ビジネスロジック上の分岐には使用しない。

## 影響範囲・結果（Consequences）

* **プラス面:**
    * ドメイン層から `try-catch` が排除され、ロジックの流れが直線的（Railway）になる。
    * テストコードにおいて、異常系の検証が `assert(result.isFailure())` となり直感的になる。

* **マイナス面・注意点（重要）:**
    * **トランザクション制御の注意**: `Result.failure` を返しても、Javaの例外機構を経由しないため、**Springの `@Transactional` はロールバックをトリガーしない。**
    * **対策:** Service層において `Result.failure` を検知した場合、明示的に `TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()` を呼び出す必要がある。

* **将来の拡張:**
    * `Result` クラスに `map`, `flatMap`, `recover` などのメソッドを実装し、モナドとして扱えるようにする。

## 関連ADR
* なし